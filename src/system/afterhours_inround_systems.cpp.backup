#include "system_manager.h"
#include "afterhours_systems.h"
#include "../components/indexer.h"
#include "../components/can_hold_item.h"
#include "../components/is_item_container.h"
#include "../components/transform.h"

// Individual system headers for inround systems
#include "pass_time_for_active_fishing_games_system.h"
#include "process_conveyer_items_system.h"
#include "process_grabber_filter_system.h"
#include "process_grabber_items_system.h"
#include "process_has_rope_system.h"
#include "process_pnumatic_pipe_movement_system.h"
#include "process_spawner_system.h"
#include "reduce_impatient_customers_system.h"
#include "reset_customers_that_need_resetting_system.h"
#include "reset_empty_work_furniture_system.h"

namespace system_manager {

// System for processing containers that should update items during in-round
// updates
struct ProcessIsContainerAndShouldUpdateItemSystem
    : public afterhours::System<Transform, IsItemContainer, Indexer,
                                CanHoldItem> {
    virtual ~ProcessIsContainerAndShouldUpdateItemSystem() = default;

    virtual bool should_run(const float) override {
        if (!GameState::get().is_game_like()) return false;
        try {
            Entity& sophie = EntityHelper::getNamedEntity(NamedEntity::Sophie);
            const HasDayNightTimer& hastimer = sophie.get<HasDayNightTimer>();
            // Don't run during transitions to avoid spawners creating entities
            // before transition logic completes
            if (hastimer.needs_to_process_change) return false;
            return hastimer.is_nighttime();
        } catch (...) {
            return false;
        }
    }

    // TODO fold in function implementation
    virtual void for_each_with(Entity& entity, Transform& transform,
                               IsItemContainer& iic, Indexer& indexer,
                               CanHoldItem& canHold, float dt) override {
        (void) transform;  // Unused parameter
        (void) iic;        // Unused parameter
        (void) indexer;    // Unused parameter
        (void) canHold;    // Unused parameter
        system_manager::process_is_container_and_should_update_item(entity, dt);
    }
};

}  // namespace system_manager

// System for processing indexed containers holding incorrect items during
// in-round updates
struct ProcessIsIndexedContainerHoldingIncorrectItemSystem
    : public afterhours::System<Indexer, CanHoldItem> {
    virtual ~ProcessIsIndexedContainerHoldingIncorrectItemSystem() = default;

    virtual bool should_run(const float) override {
        if (!GameState::get().is_game_like()) return false;
        try {
            Entity& sophie = EntityHelper::getNamedEntity(NamedEntity::Sophie);
            const HasDayNightTimer& hastimer = sophie.get<HasDayNightTimer>();
            // Don't run during transitions to avoid spawners creating entities
            // before transition logic completes
            if (hastimer.needs_to_process_change) return false;
            return hastimer.is_nighttime();
        } catch (...) {
            return false;
        }
    }

    // TODO fold in function implementation
    virtual void for_each_with(Entity& entity, Indexer& indexer,
                               CanHoldItem& canHold, float dt) override {
        (void) indexer;  // Unused parameter
        (void) canHold;  // Unused parameter
        system_manager::process_is_indexed_container_holding_incorrect_item(entity, dt);
    }
};

// Forward declarations for systems defined in system_manager namespace
namespace system_manager {
struct ProcessIsContainerAndShouldUpdateItemSystem;
struct ProcessIsIndexedContainerHoldingIncorrectItemSystem;
}

void SystemManager::register_inround_systems() {
    systems.register_update_system(
        std::make_unique<
            system_manager::ResetCustomersThatNeedResettingSystem>());
    systems.register_update_system(
        std::make_unique<system_manager::ProcessGrabberItemsSystem>());
    systems.register_update_system(
        std::make_unique<system_manager::ProcessConveyerItemsSystem>());
    systems.register_update_system(
        std::make_unique<system_manager::ProcessGrabberFilterSystem>());
    systems.register_update_system(
        std::make_unique<system_manager::ProcessHasRopeSystem>());
    systems.register_update_system(
        std::make_unique<system_manager::ProcessPnumaticPipeMovementSystem>());
    // should move all the container functions into its own
    // function?
    systems.register_update_system(
        std::make_unique<
            system_manager::ProcessIsContainerAndShouldUpdateItemSystem>());
    // This one should be after the other container ones
    systems.register_update_system(
        std::make_unique<
            system_manager::
                ProcessIsIndexedContainerHoldingIncorrectItemSystem>());

    systems.register_update_system(
        std::make_unique<system_manager::ProcessSpawnerSystem>());
    systems.register_update_system(
        std::make_unique<system_manager::ResetEmptyWorkFurnitureSystem>());
    systems.register_update_system(
        std::make_unique<system_manager::ReduceImpatientCustomersSystem>());

    systems.register_update_system(
        std::make_unique<
            system_manager::PassTimeForActiveFishingGamesSystem>());
}
